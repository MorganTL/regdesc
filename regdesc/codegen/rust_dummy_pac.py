import argparse
from pathlib import Path
from shlex import split
import shutil
from subprocess import run
import sys

import jinja2

from .template import get_template, get_device_desc


def get_arguments():
    parser = argparse.ArgumentParser()
    parser.add_argument("device")
    parser.add_argument("crate_dir", type=Path)

    return parser.parse_args()


def cargo_init(wd):
    run(split("cargo init --lib"), cwd=wd)


def cargo_add_dependencies(wd, deps):
    run(split(f"cargo add {' '.join(deps)}"), cwd=wd)


def gen_rust_bindings(wd, svd):
    shutil.rmtree(wd / "src")
    run(split("svd2rust --target none"), input=svd.encode(), cwd=wd)
    run(split("form -o src/ -i lib.rs"), cwd=wd)
    (wd / "lib.rs").unlink()
    run(split("cargo fmt"), cwd=wd)


def patch_rust_bindings(wd, device_desc):
    memsize = sum(reg["width"] for reg in device_desc["registers"]) // 8

    env = jinja2.Environment(
        variable_start_string="<<",
        variable_end_string=">>",
    )
    tpl = env.from_string(LIB_TPL)
    with (wd / "src" / "lib.rs").open("w") as fp:
        print(tpl.render(memsize=memsize), file=fp)

    run(split("cargo fmt"), cwd=wd)


def get_svd(device):
    device_desc = get_device_desc(device)
    tpl = get_template("cmsis.tpl.svd")

    return device_desc, tpl.render(device_desc)


def ep_rust_dummy_pac():
    args = get_arguments()

    d = args.crate_dir
    d.mkdir(exist_ok=True)
    cargo_init(d)
    cargo_add_dependencies(d, ["bare-metal@0.2.5", "vcell@0.1.2"])

    try:
        device_desc, svd = get_svd(args.device)
    except (ValueError, IOError) as e:
        sys.exit(str(e))

    gen_rust_bindings(d, svd)
    patch_rust_bindings(d, device_desc)


LIB_TPL = """
// generated by svd2rust 0.17.0 (https://github.com/rust-embedded/svd2rust)
// patched to use a stack array as memory buffer instead of the device's memory
#![deny(const_err)]
#![deny(improper_ctypes)]
#![deny(no_mangle_generic_items)]
#![deny(non_shorthand_field_patterns)]
#![deny(overflowing_literals)]
#![deny(path_statements)]
#![deny(patterns_in_fns_without_body)]
#![deny(private_in_public)]
#![deny(unconditional_recursion)]
#![deny(unused_allocation)]
#![deny(unused_comparisons)]
#![deny(unused_parens)]
#![deny(while_true)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![no_std]

extern crate bare_metal;
extern crate vcell;
use core::ops::Deref;

#[allow(unused_imports)]
use generic::*;
#[doc = r"Common register and bit access and modify traits"]
pub mod generic;
#[doc = "regs"]
pub struct REGS {
    mem: [u8; << memsize >>],
}

unsafe impl Send for REGS {}
impl REGS {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub fn ptr(&self) -> *const regs::RegisterBlock {
        &self.mem as *const u8 as *const _
    }
}

impl Deref for REGS {
    type Target = regs::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*self.ptr() }
    }
}

#[doc = "regs"]
pub mod regs;

#[no_mangle]
static mut DEVICE_PERIPHERALS: bool = false;

#[doc = r"All the peripherals"]
#[allow(non_snake_case)]
pub struct Peripherals {
    #[doc = "REGS"]
    pub REGS: REGS,
}

impl Peripherals {
    #[doc = r"Returns all the peripherals *once*"]
    #[inline]
    pub fn take() -> Option<Self> {
        if unsafe { DEVICE_PERIPHERALS } {
            None
        } else {
            Some(unsafe { Peripherals::steal() })
        }
    }

    #[doc = r"Unchecked version of `Peripherals::take`"]
    #[inline]
    pub unsafe fn steal() -> Self {
        DEVICE_PERIPHERALS = true;
        Peripherals {
            REGS: REGS {
                mem: [0u8; << memsize >>],
            },
        }
    }
}
"""
